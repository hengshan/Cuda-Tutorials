# 第6课讲义：矩阵乘法 - 朴素实现

## 课前回顾 (1分钟)

前面3课（第3-5课）我们完成了：
- 数组归约优化：加速
- 掌握了：统一内存、共享内存、Warp Shuffle

**今天开始新项目**：矩阵乘法（GPU的杀手级应用）

---

## 今天要解决的问题 (1分钟)

**任务**：计算矩阵乘法 C = A × B
- A: 1024 × 1024
- B: 1024 × 1024
- C: 1024 × 1024

**计算量**：2 × 1024³ ≈ 21亿次浮点操作

**目标**：
1. 实现一个能跑的GPU版本
2. 理解性能瓶颈在哪
3. 为下节课优化做准备

---

## 核心概念速讲 (3分钟)

### 1. 矩阵乘法定义

**公式**：C[i][j] = Σ A[i][k] × B[k][j]
```
C[0][0] = A[0][0]*B[0][0] + A[0][1]*B[1][0] + ... + A[0][K-1]*B[K-1][0]
         |<-------- 需要K次乘法和K次加法 -------->|
```

**示例**（2×2矩阵）：
```
[1 2]   [5 6]   [1*5+2*7  1*6+2*8]   [19 22]
[3 4] × [7 8] = [3*5+4*7  3*6+4*8] = [43 50]
```

---

### 2. 内存布局：行主序

**2D矩阵在内存中是1D数组**：
```
矩阵:         内存:
[0 1 2]      [0 1 2 3 4 5 6 7 8]
[3 4 5]       └─行0─┘└─行1─┘└─行2─┘
[6 7 8]

访问 matrix[i][j] = array[i * width + j]
```

**C[2][1]在哪？** → array[2 * 3 + 1] = array[7] = 7

---

### 3. GPU映射：一个线程算一个C元素

**2D线程网格**：
```
Block (16×16=256线程)
┌───┬───┬───┐
│ ● │ ● │ ● │  每个●是一个线程
├───┼───┼───┤  每个线程负责计算C的一个元素
│ ● │ ● │ ● │
└───┴───┴───┘

Grid (多个Block覆盖整个C矩阵)
```

**线程(i,j)的任务**：
- 读取A的第i行（K个元素）
- 读取B的第j列（K个元素）
- 计算点积得到C[i][j]

---

### 4. 性能指标：GFLOPS

**FLOPS** = Floating Point Operations Per Second（每秒浮点操作数）

**矩阵乘法的操作数**：
- 每个C元素：K次乘法 + K次加法 = 2K次操作
- 总共：M × N × 2K次操作

**示例**（1024³）：
- 操作数：2 × 1024³ = 2,147,483,648 ≈ 2.15 GFLOP
- 如果耗时 20ms = 0.02秒
- 性能：2.15 / 0.02 = 107.5 GFLOPS

**对比**：
- RTX 5090 FP32峰值：~90,000 GFLOPS (90 TFLOPS)
- 朴素实现：~100 GFLOPS
- 利用率：0.1%（很低！）

---

## 今天的代码结构

```cuda
__global__ void matmul(float *A, float *B, float *C,
                       int M, int N, int K) {
    // 1. 计算线程负责的C元素位置
    int row = blockIdx.y * blockDim.y + threadIdx.y;
    int col = blockIdx.x * blockDim.x + threadIdx.x;

    // 2. 边界检查
    if (row < M && col < N) {
        float sum = 0.0f;

        // 3. 计算点积：A的row行 × B的col列
        for (int k = 0; k < K; k++) {
            sum += A[row * K + k] * B[k * N + col];
            //     └─A[row][k]─┘   └──B[k][col]──┘
        }

        // 4. 写回结果
        C[row * N + col] = sum;
    }
}

// 启动配置：
dim3 block(16, 16);  // 16×16 = 256线程
dim3 grid((N+15)/16, (M+15)/16);  // 64×64 = 4096个blocks
```

---

## 性能问题分析（下节课要解决）

### 问题1：重复读取全局内存

**A[row][k]被读多少次？**
- 同一行的16个线程（计算C[row][0]到C[row][15]）
- 都要读A[row][k]
- **重复读了16次！浪费！**

**B[k][col]被读多少次？**
- 同一列的16个线程
- 也是重复读了16次

### 问题2：B的列访问跨步

```
B[0][col]: 内存地址 = col
B[1][col]: 内存地址 = N + col  (跨了N个元素)
B[2][col]: 内存地址 = 2N + col
...
```
跨步访问 → 缓存不友好 → 慢

---

## 本节课目标

学完后你应该能：
- ✅ 理解矩阵乘法算法
- ✅ 会用2D线程网格
- ✅ 计算GFLOPS性能
- ✅ 分析性能瓶颈
- ✅ 知道为什么朴素版很慢

---

## 接下来：20分钟 Live Coding

重点：
1. 2D线程索引计算
2. 行主序内存访问
3. 边界检查处理
4. 性能测量和GFLOPS计算
5. 分析为什么这么慢

**下节课预告**：Tiling优化！

准备好了吗？开始写矩阵乘法！💪
